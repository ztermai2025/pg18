## WAL文件的管理

我们知道WAL文件的尺寸是固定的，缺省是16MB。随着往它里面写入的WAL记录不断增加，必然存在一个写满的时候。当一个WAL文件被写满后，数据库实例会自动创建一个新的WAL文件，这个过程叫作WAL文件的切换(WAL segment switch)。你也可以手工执行pg_switch_wal()函数来强制数据库实例进行WAL文件的切换。下面的实验展示了如何手工切换WAL文件：
```
postgres=# SELECT pg_current_wal_lsn(); /* 查看当前WAL指针 */
 pg_current_wal_lsn
--------------------
 0/18CB150
(1 row)
postgres=# \! ls -l $PGDATA/pg_wal /* 查看pg_wal目录下的WAL文件 */
total 16388
-rw------- 1 postgres postgres 16777216 Oct 28 13:19 000000010000000000000001
drwx------ 2 postgres postgres     4096 Oct 28 05:45 archive_status
```
我们可以看到，因为当前的LSN指针是0/18CB150，它属于1号WAL文件，在pg_wal目录下只有这一个WAL文件。现在我们执行手工切换：
```
postgres=# SELECT pg_switch_wal(); /* 手工执行WAL文件的切换 */
 pg_switch_wal
---------------
 0/18CB1A0
(1 row)
postgres=# SELECT pg_current_wal_lsn(); /* 查看当前WAL指针 */
 pg_current_wal_lsn
--------------------
 0/2000060
(1 row)
postgres=# \! ls -l $PGDATA/pg_wal /* 查看pg_wal目录下的WAL文件，结果产生一个新的WAL文件，编号为2 */
total 32772
-rw------- 1 postgres postgres 16777216 Oct 28 13:20 000000010000000000000001
-rw------- 1 postgres postgres 16777216 Oct 28 13:20 000000010000000000000002
drwx------ 2 postgres postgres     4096 Oct 28 05:45 archive_status
postgres=#
```
可以看出，当我们手工切换后，当前LSN指针变成了0/2000060，它所在的WAL文件是2号，所以1号WAL文件就变成了老的WAL文件。此时在pg_wal目录下我们可以看到1号和2号两个WAL文件。这里需要注意的一点是：在手工切换过程中，如果从上一次切换到现在，并没有产生新的WAL记录，则PostgreSQL会拒绝进行切换。所以你如果连续快速地做几次手动切换，你会发现有时候并没有产生新的WAL文件，原因就是你切换的太快，在两次切换之间并没有产生新的WAL文件，则PostgreSQL认为没有切换的必要。

WAL文件的切换触发条件有3个：第一个就是手工切换，当然这种情况比较少，毕竟很少有人闲着没事手工切换着玩。第二种就是当WAL文件写满后，就自动切换，这种情况最频繁。第三种情况是当数据库处于归档模式时，参数archive_timeout规定了一个时间间隔，当超过这个时间间隔后，检查点进程会自动执行一次WAL文件的切换，具体可以参阅源代码checkpointer.c中的CheckArchiveTimeout()函数。

数据库实例把所有的WAL文件都存放在$PGDATA/pg_wal目录下，随着时间的推移，里面积累的WAL文件势必越来越多，这就存在一个清理的问题。那么，哪些WAL文件是当前数据库所不需要的呢？很显然，最近一次成功执行的检查点对应的重做点之前的WAL记录是当前运行的数据库不需要的，可以被删除掉，如图3.30所示。

![](x0118.svg) <!-- WAL文件可以被删除的条件 -->

如上图所示，最后一次检查点的WAL记录在n号WAL文件上，它的重做点在n-1号WAL文件上，则编号为n-2的WAL文件和以前的WAL文件都可以被安全的删除了。当然，这些能被删除的老的WAL文件加上物理备份，可以把数据库恢复到重做点之前的某一个状态，这就是下一章要介绍的备份和归档模式，本节只考虑崩溃恢复的需要，不考虑归档。每次检查点完成后，数据库集群会根据一定的算法，来决定删除哪些旧的WAL文件，以免撑爆pg_wal目录，这个WAL文件的清理工作是由检查点进程在执行检查点操作时执行的。PostgreSQL提供了两个参数，规定了在pg_wal目录下的WAL文件的体积的上限和下限。参数min_wal_size定义了需要保存的最少的WAL文件的体积，它的缺省单位是MB，缺省值是80MB。如果WAL文件的体积是16MB，则80MB意味着在pg_wal目录下必须保存5个WAL文件。当pg_wal目录下WAL文件的体积小于min_wal_size规定的值时，即将被删除的老的WAL文件并不会被删除，而是重新改名，变成新的WAL文件加以利用。参数max_wal_size规定了WAL文件的最大体积，它的缺省单位是MB，缺省值是1024MB。一旦pg_wal目录下所有的WAL文件的总体积超过了max_wal_size，数据库集群就会强制发生一次检查点，确保目前的WAL文件可以删除掉。max_wal_size的值是软性指标，在一些情况下，譬如归档失败，复制槽对应的备库宕机等情况下，pg_wal目录下的WAL文件可能会积累出比max_wal_size多得多的WAL文件。

数据库的负荷不同，数据修改的频度也不同。活跃的数据库几秒钟就要切换一下WAL文件，而相对静止的数据库很长时间也不会把一个WAL文件填满。每次发生检查点时，PostgreSQL会预先分配一定数量的WAL文件，保持一定的富裕度。到底预留多少个WAL文件合适呢？很显然这没有一个绝对的数值，需要根据数据库的活跃程度进行动态调整。一个很自然的算法是：根据本次检查点和上一次检查点的距离来确定所需要预留的WAL文件的数量。WAL文件被自动删除，在备份和流复制领域是一个需要关注的问题，这个问题会在后续章节进行讨论。



